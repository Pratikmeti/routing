<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 7.6.4.1 (Linux)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="00:00:00"/>
	<style type="text/css">
		@page { size: 8.27in 11.69in; margin: 0.79in }
		p { line-height: 115%; margin-bottom: 0.1in; background: transparent }
		pre { background: transparent }
		pre.western { font-family: "Liberation Mono", monospace; font-size: 10pt }
		pre.cjk { font-family: "NSimSun", monospace; font-size: 10pt }
		pre.ctl { font-family: "Liberation Mono", monospace; font-size: 10pt }
	</style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr"><pre class="western">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Interactive Route Planner&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;style&gt;
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            cursor: crosshair;
            touch-action: none;
        }
        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body class=&quot;bg-gray-900 text-white flex flex-col h-screen antialiased&quot;&gt;

    &lt;!-- Header --&gt;
    &lt;header class=&quot;bg-gray-800 shadow-lg z-10&quot;&gt;
        &lt;div class=&quot;container mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;
            &lt;div class=&quot;flex items-center justify-between h-16&quot;&gt;
                &lt;h1 class=&quot;text-2xl font-bold text-white&quot;&gt;Route Planner&lt;/h1&gt;
                &lt;div class=&quot;flex items-center space-x-4&quot;&gt;
                    &lt;label for=&quot;file-upload&quot; class=&quot;relative cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105&quot;&gt;
                        &lt;span&gt;Load map.osm File&lt;/span&gt;
                        &lt;input id=&quot;file-upload&quot; name=&quot;file-upload&quot; type=&quot;file&quot; class=&quot;sr-only&quot; accept=&quot;.osm&quot;&gt;
                    &lt;/label&gt;
                    &lt;button id=&quot;reset-button&quot; class=&quot;bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105&quot;&gt;Reset&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/header&gt;

    &lt;!-- Main Content --&gt;
    &lt;main class=&quot;flex-grow flex items-stretch overflow-hidden&quot;&gt;
        &lt;!-- Sidebar --&gt;
        &lt;aside class=&quot;w-full sm:w-80 bg-gray-800 p-6 flex-shrink-0 overflow-y-auto&quot;&gt;
            &lt;h2 class=&quot;text-xl font-semibold mb-4 border-b border-gray-700 pb-2&quot;&gt;Instructions&lt;/h2&gt;
            &lt;div id=&quot;instructions&quot; class=&quot;space-y-4 text-gray-300&quot;&gt;
                &lt;div class=&quot;flex items-start&quot;&gt;
                    &lt;div class=&quot;flex-shrink-0 h-6 w-6 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold mr-3&quot;&gt;1&lt;/div&gt;
                    &lt;p&gt;Click &quot;Load map.osm File&quot; to load your map data.&lt;/p&gt;
                &lt;/div&gt;
                 &lt;div class=&quot;flex items-start&quot;&gt;
                    &lt;div class=&quot;flex-shrink-0 h-6 w-6 rounded-full bg-gray-600 text-white flex items-center justify-center font-bold mr-3&quot;&gt;2&lt;/div&gt;
                    &lt;p&gt;Click anywhere on the map to set the **start point**.&lt;/p&gt;
                &lt;/div&gt;
                 &lt;div class=&quot;flex items-start&quot;&gt;
                    &lt;div class=&quot;flex-shrink-0 h-6 w-6 rounded-full bg-gray-600 text-white flex items-center justify-center font-bold mr-3&quot;&gt;3&lt;/div&gt;
                    &lt;p&gt;Click a second time to set the **end point** and find the path.&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&quot;status&quot; class=&quot;mt-6 text-lg font-medium text-yellow-400&quot;&gt;&lt;/div&gt;
            &lt;div id=&quot;results&quot; class=&quot;mt-4 text-gray-300 space-y-2 hidden&quot;&gt;
                &lt;p&gt;&lt;span class=&quot;font-semibold text-white&quot;&gt;Distance:&lt;/span&gt; &lt;span id=&quot;distance&quot;&gt;&lt;/span&gt; meters&lt;/p&gt;
            &lt;/div&gt;
            &lt;div id=&quot;loading&quot; class=&quot;fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center hidden z-50&quot;&gt;
                &lt;div class=&quot;text-center&quot;&gt;
                    &lt;div class=&quot;loader mx-auto&quot;&gt;&lt;/div&gt;
                    &lt;p class=&quot;mt-4 text-xl font-semibold&quot;&gt;Parsing Map Data...&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/aside&gt;

        &lt;!-- Canvas --&gt;
        &lt;div class=&quot;flex-grow bg-gray-700 flex items-center justify-center relative overflow-hidden&quot;&gt;
            &lt;canvas id=&quot;map-canvas&quot; class=&quot;bg-gray-200 rounded-lg shadow-inner&quot;&gt;&lt;/canvas&gt;
        &lt;/div&gt;
    &lt;/main&gt;

    &lt;script&gt;
        // --- DOM Elements ---
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const fileUpload = document.getElementById('file-upload');
        const resetButton = document.getElementById('reset-button');
        const statusEl = document.getElementById('status');
        const resultsEl = document.getElementById('results');
        const distanceEl = document.getElementById('distance');
        const loadingEl = document.getElementById('loading');
        const instructionSteps = document.querySelectorAll('#instructions &gt; div');

        // --- App State ---
        let model = null;
        let startPoint = null;
        let endPoint = null;
        let path = [];
        
        // --- Canvas Panning and Zooming State ---
        let transform = { x: 0, y: 0, scale: 1 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // --- A* Node Class ---
        class Node {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.parent = null;
                this.neighbors = [];
                this.g = Infinity; // Distance from start
                this.h = 0;        // Heuristic distance to end
                this.f = Infinity; // g + h
            }

            distanceTo(otherNode) {
                return Math.sqrt(Math.pow(this.x - otherNode.x, 2) + Math.pow(this.y - otherNode.y, 2));
            }
        }

        // --- Map Model Class ---
        class RouteModel {
            constructor(xmlText) {
                this.nodes = new Map();
                this.ways = [];
                this.bounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
                this.parseOSM(xmlText);
            }

            parseOSM(xmlText) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, &quot;application/xml&quot;);
                
                // Parse bounds
                const boundsEl = xmlDoc.querySelector('bounds');
                if (boundsEl) {
                    this.bounds.minLat = parseFloat(boundsEl.getAttribute('minlat'));
                    this.bounds.maxLat = parseFloat(boundsEl.getAttribute('maxlat'));
                    this.bounds.minLon = parseFloat(boundsEl.getAttribute('minlon'));
                    this.bounds.maxLon = parseFloat(boundsEl.getAttribute('maxlon'));
                }

                // Parse nodes
                xmlDoc.querySelectorAll('node').forEach(nodeEl =&gt; {
                    const id = nodeEl.getAttribute('id');
                    const lat = parseFloat(nodeEl.getAttribute('lat'));
                    const lon = parseFloat(nodeEl.getAttribute('lon'));
                    this.nodes.set(id, new Node(id, lon, lat));
                });
                
                // Parse ways and build neighbor connections
                xmlDoc.querySelectorAll('way').forEach(wayEl =&gt; {
                    const nodeRefs = Array.from(wayEl.querySelectorAll('nd')).map(nd =&gt; nd.getAttribute('ref'));
                    this.ways.push(nodeRefs);

                    for (let i = 0; i &lt; nodeRefs.length - 1; i++) {
                        const node1 = this.nodes.get(nodeRefs[i]);
                        const node2 = this.nodes.get(nodeRefs[i + 1]);
                        if (node1 &amp;&amp; node2) {
                            node1.neighbors.push(node2);
                            node2.neighbors.push(node1);
                        }
                    }
                });
            }

            findClosestNode(x, y) {
                let closestNode = null;
                let minDistance = Infinity;

                for (const node of this.nodes.values()) {
                    const distance = Math.sqrt(Math.pow(node.x - x, 2) + Math.pow(node.y - y, 2));
                    if (distance &lt; minDistance) {
                        minDistance = distance;
                        closestNode = node;
                    }
                }
                return closestNode;
            }
        }

        // --- A* Search Algorithm ---
        function aStarSearch(startNode, endNode) {
            const openSet = new Set([startNode]);
            const cameFrom = new Map();

            startNode.g = 0;
            startNode.h = startNode.distanceTo(endNode);
            startNode.f = startNode.h;

            while (openSet.size &gt; 0) {
                let currentNode = null;
                let lowestF = Infinity;
                for (const node of openSet) {
                    if (node.f &lt; lowestF) {
                        lowestF = node.f;
                        currentNode = node;
                    }
                }

                if (currentNode === endNode) {
                    return reconstructPath(cameFrom, currentNode);
                }

                openSet.delete(currentNode);

                for (const neighbor of currentNode.neighbors) {
                    const tentativeG = currentNode.g + currentNode.distanceTo(neighbor);
                    if (tentativeG &lt; neighbor.g) {
                        cameFrom.set(neighbor, currentNode);
                        neighbor.g = tentativeG;
                        neighbor.h = neighbor.distanceTo(endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                        openSet.add(neighbor);
                    }
                }
            }
            return []; // No path found
        }

        function reconstructPath(cameFrom, current) {
            const totalPath = [current];
            while (cameFrom.has(current)) {
                current = cameFrom.get(current);
                totalPath.unshift(current);
            }
            return totalPath;
        }

        // --- Canvas Drawing ---
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight) * 0.95;
            canvas.width = size;
            canvas.height = size;
            draw();
        }

        function project(lon, lat) {
            const scale = Math.min(canvas.width / (model.bounds.maxLon - model.bounds.minLon), canvas.height / (model.bounds.maxLat - model.bounds.minLat));
            const x = (lon - model.bounds.minLon) * scale;
            const y = (model.bounds.maxLat - lat) * scale; // Invert Y-axis
            return { x, y };
        }

        function unproject(x, y) {
             const scale = Math.min(canvas.width / (model.bounds.maxLon - model.bounds.minLon), canvas.height / (model.bounds.maxLat - model.bounds.minLat));
             const lon = (x / scale) + model.bounds.minLon;
             const lat = model.bounds.maxLat - (y / scale);
             return { lon, lat };
        }

        function draw() {
            if (!model) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.scale, transform.scale);

            // Draw ways
            ctx.strokeStyle = '#a0aec0'; // gray-500
            ctx.lineWidth = 1 / transform.scale;
            ctx.beginPath();
            model.ways.forEach(way =&gt; {
                const startNode = model.nodes.get(way[0]);
                if (!startNode) return;
                const pStart = project(startNode.x, startNode.y);
                ctx.moveTo(pStart.x, pStart.y);
                for (let i = 1; i &lt; way.length; i++) {
                    const node = model.nodes.get(way[i]);
                    if (!node) continue;
                    const p = project(node.x, node.y);
                    ctx.lineTo(p.x, p.y);
                }
            });
            ctx.stroke();

            // Draw path
            if (path.length &gt; 0) {
                ctx.strokeStyle = '#e53e3e'; // red-600
                ctx.lineWidth = 4 / transform.scale;
                ctx.beginPath();
                const pStart = project(path[0].x, path[0].y);
                ctx.moveTo(pStart.x, pStart.y);
                for (let i = 1; i &lt; path.length; i++) {
                    const p = project(path[i].x, path[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            }

            // Draw start and end points
            if (startPoint) drawPoint(startPoint, '#38a169'); // green-600
            if (endPoint) drawPoint(endPoint, '#3182ce'); // blue-600

            ctx.restore();
        }
        
        function drawPoint(point, color) {
            const p = project(point.x, point.y);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6 / transform.scale, 0, 2 * Math.PI);
            ctx.fill();
        }

        // --- Event Handlers ---
        fileUpload.addEventListener('change', (event) =&gt; {
            const file = event.target.files[0];
            if (!file) return;

            loadingEl.classList.remove('hidden');
            statusEl.textContent = 'Loading and parsing map...';
            resultsEl.classList.add('hidden');

            const reader = new FileReader();
            reader.onload = (e) =&gt; {
                setTimeout(() =&gt; { // Give browser time to show loader
                    try {
                        model = new RouteModel(e.target.result);
                        resetState();
                        updateInstructionStep(1, true);
                        updateInstructionStep(2, false);
                        statusEl.textContent = 'Map loaded. Click to set start point.';
                    } catch (error) {
                        console.error(&quot;Error parsing OSM file:&quot;, error);
                        statusEl.textContent = 'Error: Could not parse map file.';
                        model = null;
                    } finally {
                        loadingEl.classList.add('hidden');
                        draw();
                    }
                }, 50);
            };
            reader.readAsText(file);
        });

        resetButton.addEventListener('click', () =&gt; {
            resetState();
            if (model) {
                statusEl.textContent = 'Map loaded. Click to set start point.';
            } else {
                statusEl.textContent = 'Load a map file to begin.';
            }
            draw();
        });

        canvas.addEventListener('mousedown', (e) =&gt; {
            if (e.button === 1) { // Middle mouse button
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });
        
        canvas.addEventListener('mousemove', (e) =&gt; {
            if (isPanning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                transform.x += dx;
                transform.y += dy;
                panStart = { x: e.clientX, y: e.clientY };
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) =&gt; {
            if (e.button === 1) {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            }
        });
        
        canvas.addEventListener('mouseleave', () =&gt; {
             isPanning = false;
             canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('wheel', (e) =&gt; {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const scaleFactor = e.deltaY &lt; 0 ? 1.1 : 0.9;
            
            transform.x = mouseX - (mouseX - transform.x) * scaleFactor;
            transform.y = mouseY - (mouseY - transform.y) * scaleFactor;
            transform.scale *= scaleFactor;
            
            draw();
        });

        canvas.addEventListener('click', (e) =&gt; {
            if (!model) return;

            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left - transform.x) / transform.scale;
            const canvasY = (e.clientY - rect.top - transform.y) / transform.scale;

            const { lon, lat } = unproject(canvasX, canvasY);
            const clickedNode = model.findClosestNode(lon, lat);

            if (!startPoint) {
                startPoint = clickedNode;
                updateInstructionStep(2, true);
                updateInstructionStep(3, false);
                statusEl.textContent = 'Start point set. Click to set end point.';
            } else if (!endPoint) {
                endPoint = clickedNode;
                updateInstructionStep(3, true);
                statusEl.textContent = 'Calculating shortest path...';
                
                // Reset g/h/f values before new search
                model.nodes.forEach(node =&gt; {
                    node.g = Infinity;
                    node.h = 0;
                    node.f = Infinity;
                });

                setTimeout(() =&gt; { // Allow UI to update
                    path = aStarSearch(startPoint, endPoint);
                    if (path.length &gt; 0) {
                        statusEl.textContent = 'Shortest path found!';
                        const totalDistance = calculatePathDistance(path);
                        distanceEl.textContent = totalDistance.toFixed(2);
                        resultsEl.classList.remove('hidden');
                    } else {
                        statusEl.textContent = 'Could not find a path between the points.';
                    }
                    draw();
                }, 50);
            }
            draw();
        });

        // --- Utility Functions ---
        function resetState() {
            startPoint = null;
            endPoint = null;
            path = [];
            resultsEl.classList.add('hidden');
            instructionSteps.forEach((step, index) =&gt; {
                updateInstructionStep(index + 1, false);
            });
            if (model) updateInstructionStep(1, true);
        }
        
        function updateInstructionStep(step, isComplete) {
            const stepEl = instructionSteps[step - 1];
            if (!stepEl) return;
            const circleEl = stepEl.querySelector('div:first-child');
            if (isComplete) {
                circleEl.classList.remove('bg-gray-600');
                circleEl.classList.add('bg-green-600');
                circleEl.innerHTML = '&amp;#10003;'; // Checkmark
            } else {
                circleEl.classList.remove('bg-green-600');
                circleEl.classList.add('bg-gray-600');
                circleEl.textContent = step;
            }
        }

        function calculatePathDistance(path) {
            let totalDistance = 0;
            for (let i = 0; i &lt; path.length - 1; i++) {
                // Using Haversine formula for distance between lat/lon points
                totalDistance += haversineDistance(path[i], path[i+1]);
            }
            return totalDistance;
        }

        function haversineDistance(node1, node2) {
            const R = 6371e3; // Earth's radius in metres
            const φ1 = node1.y * Math.PI/180;
            const φ2 = node2.y * Math.PI/180;
            const Δφ = (node2.y-node1.y) * Math.PI/180;
            const Δλ = (node2.x-node1.x) * Math.PI/180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // in metres
        }

        // --- Initial Setup ---
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        statusEl.textContent = 'Load a map file to begin.';

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</body>
</html>